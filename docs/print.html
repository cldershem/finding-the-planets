<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title> - Finding the Planets</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A book accompanying a workshop to find the planets around Trappist-1.">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        
        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

        <!-- Custom JS script -->
        

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="./about.html">What is this book about</a></li><li><a href="./background.html"><strong>1.</strong> Background</a></li><li><ul class="section"><li><a href="./background/trappist-1.html"><strong>1.1.</strong> Trappist-1</a></li><li><a href="./background/kepler.html"><strong>1.2.</strong> Kepler Spacecraft</a></li></ul></li><li><a href="./science.html"><strong>2.</strong> Science</a></li><li><ul class="section"><li><a href="./science/discovery.html"><strong>2.1.</strong> Exo-planet Discovery</a></li><li><a href="./science/position.html"><strong>2.2.</strong> Observing Position</a></li><li><a href="./science/doppler.html"><strong>2.3.</strong> Doppler Effect</a></li></ul></li><li><a href="./transit.html"><strong>3.</strong> Transit Method</a></li><li><ul class="section"><li><a href="./transit/light_curve.html"><strong>3.1.</strong> What To Look For</a></li></ul></li><li><a href="./finding.html"><strong>4.</strong> Finding Planets</a></li><li><ul class="section"><li><a href="./finding/fits.html"><strong>4.1.</strong> FITS</a></li><li><a href="./finding/csv.html"><strong>4.2.</strong> CSV</a></li><li><a href="./finding/image.html"><strong>4.3.</strong> Image</a></li><li><a href="./finding/collage.html"><strong>4.4.</strong> Collage</a></li><li><a href="./finding/brightness.html"><strong>4.5.</strong> Brightness</a></li><li><a href="./finding/detrend.html"><strong>4.6.</strong> Detrend</a></li><li><a href="./finding/filter.html"><strong>4.7.</strong> Filter</a></li></ul></li><li><a href="./setup.html">Setup</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Finding the Planets</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#what is this book about" id="what is this book about"><h1>What is this book about</h1></a>
<p>This book is an compendium to the workshop <em>Finding the Planets</em>. The workshop
walks you through various techniques and teaches you how to detect planets in
photo-metric data.</p>
<p>It starts with observations of <a href="https://en.wikipedia.org/wiki/TRAPPIST-1">Trappist-1</a>, a star system only 40
light-years from earth. It ends with finding the planets among the massaged
data. Along the way you learn how to clean up data, what we are looking for, and
how to find the actual planets.</p>
<p>This book challenges you to become a planet-hunter yourself. Together you and
your trusty silicon companion go on a journey to explore the riches of the
universe. So put on your science hat and go find those planets.</p>
<a class="header" href="print.html#background" id="background"><h1>Background</h1></a>
<p>Before we strap into our science-craft let's set the scene by learning about
the background of all those marvelous discoveries.</p>
<p>In the following chapters, you will learn more about Trappist-1, how it was
discovered and the data that we will use to find its planets.</p>
<a class="header" href="print.html#trappist-1" id="trappist-1"><h1>Trappist-1</h1></a>
<p>Trappist-1 is a star system 39 light-years from Earth. A light-year is the
distance light travels in one year. That is approximately 369 trillion
kilometers. Even though this seems an astronomically large distance, on a
galactic scale, Trappist-1 and the sun are close neighbors.</p>
<a class="header" href="print.html#kepler spacecraft" id="kepler spacecraft"><h1>Kepler Spacecraft</h1></a>
<p>The Kepler spacecraft is a satellite that orbits the sun and acts as an
telescope observing the universe without earths atmosphere interfering.</p>
<p>It was launched by NASA, as part of the Discovery Program. A program which
focused on a series of lower-cost, highly focused space missions.</p>
<a class="header" href="print.html#science" id="science"><h1>Science</h1></a>
<p>In this part we will explore the science behind exo-planet discovery. We will
detail the different methods of detecting exo-planets, and do some calculations
on what the expect.</p>
<a class="header" href="print.html#exo-planet discovery" id="exo-planet discovery"><h1>Exo-planet Discovery</h1></a>
<p>How does on discover exo-planets? This is no small feat. It makes use of
advanced technology and often relies on extensive data analysis. Below we
outline the various different ways of discovering exoplanets.</p>
<p>The various ways can be grouped in two categories. Direct observation and
indirect observation.</p>
<a class="header" href="print.html#direct observation" id="direct observation"><h2>Direct observation</h2></a>
<p>Direct observation entails taking a telescope and searching the sky in the hope
of spotting an exo-planet. Unfortunately the chances of this happening are very
low. Where we can take a telescope and point it at Jupiter and discover a few
of her moons, exo-planets are so far away and often so dim, it is impractical
for direct observation.</p>
<p>So we will quickly leave direct observation behind and look into indirect observation.</p>
<a class="header" href="print.html#indirect observation" id="indirect observation"><h2>Indirect observation</h2></a>
<p>Indirect observation entails observing a star closely and inferring the
existence of one or more planets. It relies on the science orbital mechanics. We
don't have to become physicist to get a grasp of the mechanisms involved.</p>
<p>One of the <a href="https://en.wikipedia.org/wiki/Kepler%27s_laws_of_planetary_motion">laws of planetary motion</a>
as laid down by Johannes Kepler is</p>
<blockquote>
<p>The orbit of a planet is an ellipse with the Sun at one of the two foci.</p>
</blockquote>
<p>This is not entirely true. Isaac Newton, when writing down his laws of
gravitational attraction, inferred that planets and their stars revolve around
their <em>center of mass</em>.</p>
<p>This motion lets stars wobble around their average position. And it is this
wobble that we can use to infer the existence of planets.</p>
<a class="header" href="print.html#observing position" id="observing position"><h1>Observing Position</h1></a>
<p>Similar with direct observation, we could try to observe the wobble of a star
directly. This method faces the same problems, i.e. the distances of the stars
are so immense, the wobble becomes all but undetectable.</p>
<p>So we will quickly move on to other methods.</p>
<a class="header" href="print.html#doppler effect" id="doppler effect"><h1>Doppler Effect</h1></a>
<p>Just like a blaring whistle of a train drops pitch when it rushes by, light
changes color depending if the light emitter is moving towards us or away
from us. This is called the Doppler effect.</p>
<p>By careful measurement of the Doppler effect in star light one could discover
regularities and infer the existence of planets. Even though this technique is
used to discover exo-planets, we will be making use of a different technique.</p>
<a class="header" href="print.html#transit method" id="transit method"><h1>Transit Method</h1></a>
<p>When a planet moves in between its star and the Earth, it will make the star
appear dimmer because it obscures some of the light rays. Despite that planets
are often very much smaller than their companion star, this effect is certainly
measurable.</p>
<p>It is the transit method that we will use in this workshop to detect the planets
around Trappist-1.</p>
<a class="header" href="print.html#what to look for" id="what to look for"><h1>What To Look For</h1></a>
<p>We are forming a model of a planet transit in order to make some calculations
what to expect. Our model will be fairly crude, but it will suffices for
understanding key characteristics of light curves.</p>
<p>This section has some math in it. It is used to understand how a light curve
will look when a planet transits. Feel free to skip to the result if you feel
inclined.</p>
<a class="header" href="print.html#light curve" id="light curve"><h2>Light Curve</h2></a>
<p>A <a href="https://en.wikipedia.org/wiki/Light_curve">light curve</a> is</p>
<blockquote>
<p>a graph of light intensity of a celestial object or region, as a function of
time.</p>
</blockquote>
<p>It graphs how bright some object appears in the sky over time. Our goal is to
understand what the light curve looks like when a planet transits a star.</p>
<a class="header" href="print.html#model" id="model"><h2>Model</h2></a>
<p>We are modeling our planet transit in the following crude manner. We assume the
star to be a square which radiates uniformly. The total luminosity is
\(I_{0}\). So the luminosity per area \(\rho = \frac{I_{0}}{A}\), where \(A\)
is the total area of the star.</p>
<p>We model our planet as a square as well. We will also assume that the planet
will move with uniform speed across the stars image during the transit. When the
planet is fully in front of the star, it block some of the rays of the star
diminishing the luminosity to \(I_{t} = \rho \left(A - a\right)\), where
\(a\) is the area of the planet.</p>
<p>We are interested in the relative drop in luminosity so we will divide
\(I_{t}\) by \(I_{0}\) to get</p>
<p>\[
\frac{I_{t}}{I_{0}} = \frac{\rho \left(A - a\right)}{\rho A} = 1 - \frac{a}{A}
\]</p>
<p>So the entire light curve looks something like this.</p>
<p><img src="image/light-curve.png" alt="A light curve for a planet transition" /></p>
<a class="header" href="print.html#finding planets" id="finding planets"><h1>Finding Planets</h1></a>
<p>The following chapters will guide you in writing software that will detects
planets around Trappist-1.</p>
<p>Two things will go hand in hand. Explaining what to do followed by you
implementing that in your favorite programming language.</p>
<a class="header" href="print.html#format" id="format"><h2>Format</h2></a>
<p>We will chose to adhere to the following format. In almost every chapter we will
output a Comma Separated Values (CSV) file. That file will serve as input for
the next chapter.</p>
<p>Although this could be optimized in a single pipeline, foregoing the need to
write and read CSV, with this format we have to ability to reflect. This will
aid us in understanding our task at hand.</p>
<a class="header" href="print.html#outline" id="outline"><h2>Outline</h2></a>
<p>The following outline is typical for almost all the activities we are going to
do in this workshop.</p>
<ol>
<li>Read data</li>
<li>Process data</li>
<li>Write data</li>
</ol>
<p>Processing could be any of, but not limited to, transforming, filtering,
analyzing or fitting. Now processing will be generating image data.</p>
<p>This could be your first encounter with some of the libraries we use. When we
start using a library for the first time, we are going to be very specific. Once
you get to know the library we leave you to fill in the blanks.</p>
<a class="header" href="print.html#further considerations" id="further considerations"><h2>Further Considerations</h2></a>
<p>Almost every chapter encourages you to play with what you have created. We hope
too give you some food for thought that might spark your interested. But feel
free to come up with your own questions and observations and don't forget to
share them.</p>
<a class="header" href="print.html#fits" id="fits"><h1>FITS</h1></a>
<p>The results of the NASA Kepler mission on observing Trappist-1 are
<a href="https://keplerscience.arc.nasa.gov/raw-data-for-k2-campaign-12-and-trappist-1-now-available.html">available</a>
to the public. For your ease of use we downloaded the FITS files before hand.</p>
<a class="header" href="print.html#what are fits files" id="what are fits files"><h2>What are FITS files</h2></a>
<p>A <a href="https://en.wikipedia.org/wiki/FITS">FITS</a> file is a</p>
<blockquote>
<p>open standard defining a digital file format useful for storage,
transmission and processing of scientific and other images. FITS is the most
commonly used digital file format in astronomy. Unlike many image formats,
FITS is designed specifically for scientific data and hence includes many
provisions for describing photometric and spatial calibration information,
together with image origin metadata.</p>
</blockquote>
<p>We are going to use the <a href="https://crates.io/crates/fits-rs">fits-rs</a> crate to
process the FITS files.</p>
<a class="header" href="print.html#csv" id="csv"><h1>CSV</h1></a>
<p>In this chapter we will read the FITS file and export the actual image as comma
seperated values (CSV).</p>
<a class="header" href="print.html#image" id="image"><h1>Image</h1></a>
<p>Now that we have are data in a CSV file, we are operating on it. The first thing
that we should do is make an image.</p>
<a class="header" href="print.html#artist impression" id="artist impression"><h2>Artist Impression</h2></a>
<p><img src="image/artist-impression.jpg" alt="An artist impression of Trappist-1" /></p>
<p>Often artists are commissioned to create a stunning visualization of new findings.
This is also the case with the Trappist-1 news. Above you find an artist
impression of Trappist-1.</p>
<p>The downside of this is that we could loose track of the actual data that is
used. In order to get a sense of awe for the search of exo-planets, we are
creating our own impression.</p>
<a class="header" href="print.html#creating an image" id="creating an image"><h2>Creating an image</h2></a>
<p>So go ahead and start a new Rust file named <code>image.rs</code> in the <code>src/bin</code>
directory of your project.</p>
<a class="header" href="print.html#reading data" id="reading data"><h3>Reading Data</h3></a>
<p>We will be reading our data from CSV. We will use the crate <code>simple_csv</code> for
that. In order to use it include the following lines in <code>image.rs</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate simple_csv;

use simple_csv::SimpleCsvReader;
#}</code></pre></pre>
<p>The <code>SimpleCsvReader</code> expects some sort of <code>BufReader</code>, a buffered reader. We
can create one from a <code>File</code>. So include the following modules.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fs::File;
use std::io::BufReader;
#}</code></pre></pre>
<p>And in the main function add.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let f = File::open(&quot;../long-cadence.csv&quot;).unwrap();
let buf = BufReader::new(f);
#}</code></pre></pre>
<p>Notice that we are not handling errors in a graceful way. We are just going to
arrange everything correctly and hope for the best.</p>
<p>With the <code>buf</code> we can create a CSV reader and read the first row of our data.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut reader = SimpleCsvReader::new(buf);
let row = reader.next_row().unwrap.unwrap();
#}</code></pre></pre>
<p>The unsightly double <code>unwrap</code> at the end comes from the interplay of the
<code>Iterator</code> trait that has a <code>next</code> function that returns an <code>Option</code>, and the
way <code>simple_csv</code> parses lines in CSV files. Don't worry about it now, just make
a mental note.</p>
<a class="header" href="print.html#processing data" id="processing data"><h3>Processing Data</h3></a>
<p>Our CSV file contains rows of floating point numbers. But the <code>simple_csv</code> crate
returns a slice of Strings. We will need to turn does Strings into floating
point numbers before we can properly process them.</p>
<p>We does this by iterating over the <code>row</code>. Remember how the first column
contained the time? We don't need it now so we will drop it for the moment.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut iter = row.iter();
iter.next(); // dropping time
#}</code></pre></pre>
<p>Next we can transform all the measurements in floating point numbers.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let raw: Vec&lt;f64&gt; = iter
    .map(|s| f64::from_str(s).unwrap())
    .collect();
#}</code></pre></pre>
<p>For the preceding line to work we need to include a <code>use std::str::FromStr;</code>
line at the top of our file.</p>
<p>What we are going to do is map these measurements onto a gray scale that we can
save as an image. We do this by determining the maximum measurement, determining
the relative measurement compared to the maximum, and scaling it the an integer
range from 0 to 255.</p>
<p>The following lines achieve this.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let maximum = raw
    .iter()
    .fold(std::f64::MIN, |acc, v| acc.max(*v));
let data: Vec&lt;u8&gt; = raw
    .iter()
    .map(|s| s/maximum)
    .map(|s| 255.0 * s)
    .map(|s| s.floor() as u8)
    .collect();
#}</code></pre></pre>
<a class="header" href="print.html#writing data" id="writing data"><h2>Writing data</h2></a>
<p>Now that we have the gray-scale data, it is time to write it as an image. For
this we will use the <code>png</code> crate. Before we can use it add</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate png;
#}</code></pre></pre>
<p>To the top of the source file. We also need to include an import statement that
makes our live working with PNGs easier.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use png:HasParameters;
#}</code></pre></pre>
<p>We are going to save the PNG into our working directory. Because the <code>png</code> crate
expects a <code>BufWriter</code> we will have to include the following modules.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::env;
use std::io::{BufWriter, BufReader};
#}</code></pre></pre>
<p>Notice that we already had imported the <code>BufReader</code> module. With these imports
we can create a <code>BufWriter</code> in one fell swoop.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut path = env::current_dir().unwrap();
path.push(format!(&quot;trappist-1.{}.png&quot;, 0));
let file = File::create(path).unwrap();
let ref mut w = BufWriter::new(file);
#}</code></pre></pre>
<p>Now we can hand over this <code>BufWriter</code> to a PNG <code>Encoder</code>, configure it to our
liking, create a PNG <code>Writer</code> and write the data.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut encoder = png::Encoder::new(w, 11, 11);
encoder.set(png::ColorType::Grayscale).set(png::BitDepth::Eight);
let mut writer = encoder.write_header().unwrap();
writer.write_image_data(data.as_slice()).unwrap();
#}</code></pre></pre>
<a class="header" href="print.html#our image" id="our image"><h2>Our Image</h2></a>
<p>It is finally time to make our own impression of Trappist-1. Use <code>cargo</code> to
build and run your code.</p>
<pre><code class="language-shell">&gt; cargo build
&gt; cargo run --bin image
</code></pre>
<p>Which creates</p>
<p><img src="image/trappist-1.0.png" alt="Actual Trappist-1 photo" /></p>
<a class="header" href="print.html#appreciate the image" id="appreciate the image"><h2>Appreciate the Image</h2></a>
<p>At first glance the image can be a little underwhelming. But it is precisely
this image that blew my mind! Being accustomed to the marvelous artist
impression, when I learned about the actual data was 11x11 pixels I was hooked.
How could anyone extract so much information from so little data?</p>
<p><img src="image/trappist-1.0.large.png" alt="10 times enlargement of actual Trappist-1 photo" /></p>
<p>I had to know and I hope you want to know too!</p>
<a class="header" href="print.html#further considerations-1" id="further considerations-1"><h2>Further Considerations</h2></a>
<ul>
<li>Make a bigger image with larger &quot;pixels&quot;.</li>
<li>Make an entire series of images, one for each row.</li>
<li>Make a GIF or movie of the images.</li>
</ul>
<a class="header" href="print.html#collage" id="collage"><h1>Collage</h1></a>
<p>In this chapter we will create a Collage of all the image in the long cadence
file. Although it is a bit of a side-track, we will learn valuable things by
looking at the image.</p>
<p>If you want, you can take a <a href="image/collage.png">sneak peek</a>.</p>
<p>We will not go into details of reading the data and writing the transformed
data. We assume that the previous chapters have given enough examples to learn
from. Instead we are going to focus on processing the data.</p>
<a class="header" href="print.html#processing" id="processing"><h2>Processing</h2></a>
<p>There are a few questions we need to answer before we can create our collage.</p>
<ol>
<li>For a row of data and a column in that row, which pixel should we paint?</li>
<li>What color should we paint that pixel?</li>
</ol>
<a class="header" href="print.html#position" id="position"><h3>Position</h3></a>
<p>When we created the single image, we did not have to think about positioning
explicitly. Because we want to make a collage we have some work to do.</p>
<p>First of all, lets state some facts.</p>
<ol>
<li>Each image is 11x11 pixels.</li>
<li>There are 3599 rows of images.</li>
</ol>
<p>The interesting thing about 3599 is that is 61x59. So we could make our collage
almost a square with 61 columns and 59 rows of single images. With 11x11 images
as base our collage will come in at 61x11 = 671 by 59x11 = 649.</p>
<p>There are two factors that determine the position of the pixel. The which row
that data is from, and which column the data is in.</p>
<p>We will start with the row. Because we have 61 images along the x-axis of our
collage, the <code>X</code>-offset will be</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let offset_X = row_index % 61;
#}</code></pre></pre>
<p>After 61 rows, we need to increase the <code>Y</code>-offset with one. This amounts to</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let offset_Y = row_index / 61;
#}</code></pre></pre>
<p>Now for the offset within the image. The image is 11x11. So given an original
index in the row, we have for the</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let offset_x = original_index % 11;
let offset_y = original_index / 11;
#}</code></pre></pre>
<p>Now we can calculate the target index. For each <code>offset_Y</code> we need to go down an
entire 11 rows in our collage. This is 11x61x11 = 7381. For each <code>offset_X</code> we
need to shift 11 pixels down. For each <code>offset_y</code> we need to go down an entire
row. This is 61x11 = 671. Finally, for each <code>offset_x</code> we need to shift 1 pixel
down. All together this is</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let target_index = offset_Y * 7381 +
                   offset_X * 11 +
                   offset_y * 671 +
                   offset_x
#}</code></pre></pre>
<p>With these calculations we know where to paint the image pixel.</p>
<a class="header" href="print.html#color" id="color"><h3>Color</h3></a>
<p>From our experience from creating an image we have a fairly good idea which
color to use. The only difference between the collage and the single image is
that we want to use the same scale for each image.</p>
<p>So instead of dividing our value by the maximum value of a single image, we
should divide by the global maximum.</p>
<p>Create a separate executable that will determine the global maximum of all the
measurements that we can use in determining the color of the pixel.</p>
<a class="header" href="print.html#further considerations-2" id="further considerations-2"><h2>Further Considerations</h2></a>
<p>The following suggestions might help your understanding of the problem we
facing, i.e. detecting planets in our image.</p>
<p>Take a long good look at your collage. Write down what you notice about the
image. Ask yourself some questions and discuss your observations with somebody
else.</p>
<p>Why do we need a global maximum? What would happen if we would stick to the
maximum per image? What would that look like, and what would it tell you?</p>
<a class="header" href="print.html#brightness" id="brightness"><h1>Brightness</h1></a>
<p>We are going to detect the planets by observing drops in overall brightness.
Before we are able to do this, we need to calculate the brightness. That is
precisely the objective in this chapter.</p>
<p>We are going to create a CSV file with the first column the time of the
measurement and the second column the brightness at that time.</p>
<a class="header" href="print.html#processing-1" id="processing-1"><h2>Processing</h2></a>
<p>For each row of data we would like to know how much Trappist-1 is radiating.
What we are going to do is the following.</p>
<p>Take a row of data and</p>
<ol>
<li>Convert each value to a <code>f64</code>.</li>
<li>Sum all the values to get the overall brightness.</li>
</ol>
<p>Converting values to a <code>f64</code> is something we did before. We are not going into
details for the conversion.</p>
<p>The summation of all the values can be written down very succinctly because the
<a href="https://doc.rust-lang.org/std/iter/"><code>Iterator</code></a> trait has a trick up it's
sleeve.</p>
<p>It defines a method <code>fold</code> with the following signature</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn fold&lt;B, F&gt;(self, init: B, f: F) -&gt; B
    where
        F: FnMut(B, Self::Item) -&gt; B
#}</code></pre></pre>
<p>It takes something that implements the <code>Iterator</code> trait, a initial value called
<code>init</code> and repeatedly calls <code>f</code>. The function <code>f</code> accepts two arguments. At
first it accepts the initial <code>init</code> value and the first element the <code>Iterator</code>
produces. After that it accepts the previous call to <code>f</code> return value with the
next value of the iterator. A fold returns the final return value of the
function <code>f</code>.</p>
<p>We can use it to calculate the sum of all the brightness values. If we have our
raw <code>f64</code> values in the variable <code>raw</code>, we can determine the sum with</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let sum: f64 = raw
    .iter()
    .fold(0f64, |acc, v| acc+v);
#}</code></pre></pre>
<a class="header" href="print.html#removing background" id="removing background"><h3>Removing Background</h3></a>
<p>If we take a look at one of the images</p>
<p><img src="image/trappist-1.0.large.png" alt="Enlargement of an image of Trappist-1" /></p>
<p>we see that the background is not pitch black. This means that the background
adds to the brightness, even though it does not contribute to the signal. So we
start our journey with something we will come very familiar with, we will clean
up our data.</p>
<p>What we are going to do is ignore the brightness value of anything below the
average brightness. This transforms the image from above into the image below.</p>
<p><img src="image/trappist-1.0.nobg.large.png" alt="Enlargement of an image of Trappist-1 with background removed" /></p>
<p>Still not perfect, but it is better than nothing.</p>
<p>In order to filter out the unwanted background we are going to need to know the
average. We already know the sum, we just calculated it, so the average can be
determined by</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let average = sum / (row.len() as f64);
#}</code></pre></pre>
<p>Calculating the contribution of the values above the average can still be done
succinctly. What we need to do is filter out the values that we want to sum.
I.e. the values above the average.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let filtered: f64 = raw
    .iter().
    .filter(|&amp;v| *v &gt;= average)
    .fold(0f64, |acc, v| acc+v)
#}</code></pre></pre>
<a class="header" href="print.html#graphing results" id="graphing results"><h2>Graphing Results</h2></a>
<p>Once you wrote your brightness results to a CSV file, they are ready for the
following step. But if you are like me you probably want to see your results.
This is where gnuplot comes in.</p>
<p>If you have saved your results as <code>brightness.csv</code>, the following gnuplot
session will plot your data.</p>
<pre><code>set datafile separator ','

plot [2905:2985] &quot;brightness.csv&quot; using 1:2
</code></pre>
<p>We will annotate the above example a little, so that you can use gnuplot on your
own. The <code>simple_csv</code> library outputs CSV files with a comma as separator. This
difference from the default assumption of gnuplot. Luckily this can be remedied
with the first line.</p>
<p>The second line display the core of gnuplot; the <code>plot</code> command. The first
argument, i.e. <code>[2905:2985]</code>, defines the range on the x-axis. It is optional
and will be inferred by gnuplot if it isn't present. If there would be a second
argument of that form, i.e. <code>[min:max]</code>, that would be the range on the y-axis.
Here it is inferred.</p>
<p>The <code>&quot;brightness.csv&quot;</code> argument you probably recognize as the file you wrote
your data to. The <code>plot</code> command will use data in this file to plot.</p>
<p>The last refers to columns in the data. <code>using 1:2</code> tells the plot command to
plot point with the first column as x-coordinate and the second column as
y-coordinate.</p>
<p>For a more extensive explanation of gnuplot we refer you to the
<a href="http://www.gnuplot.info/">gnuplot homepage</a>.</p>
<p>If you have gone to the trouble of outputting the brightness with and without
the background, your plot could look like the one below.</p>
<p><img src="image/brightness-both.png" alt="Plot of brightness, with and without background contribution" /></p>
<a class="header" href="print.html#further considerations-3" id="further considerations-3"><h2>Further Considerations</h2></a>
<p>Take a look at your data and write down what stands out to you. Discuss this
with a neighbor.</p>
<p>Why is the average taken as a cut-off value? What are other options?</p>
<p>There is an obvious gap in our data. This is where the Kepler satellite stopped
recording data due to a software reboot initiated by a cosmic ray event.
Although the data was lost, the satellite still operates nominally.</p>
<p>Furthermore there is a trend in the overall brightness, more pronounced in the
data with the background. This is also seen in our collage. We will have to
smooth out that trend and that is precisely what we will in one of the next chapters.</p>
<a class="header" href="print.html#detrend" id="detrend"><h1>Detrend</h1></a>
<p>Take a look the brightness graph you made in the preceding chapter.</p>
<p><img src="image/brightness.png" alt="Brightness of Trappist-1" /></p>
<p>Notice how the graph tends to flare up. This is a systemic problem that we
should correct. We are going to do that by finding what trend the graph is
following, and adjusting for that.</p>
<a class="header" href="print.html#filter" id="filter"><h1>Filter</h1></a>
<p>Take a look the detrended brightness graph you made in the preceding chapter.</p>
<p><img src="image/detrend.png" alt="Detrended brightness of Trappist-1" /></p>
<p>There are clear bands of data. I.e. regions where most of the data-points lie.
But what also stands out enormous are
<a href="https://en.wikipedia.org/wiki/Outlier">outliers</a>. For example, most points are
below 18000, but some shoot out all the way to 28000. They are clearly
erroneous.</p>
<p>There are various reasons how these outliers can occur. Some are the results of
satellite maneuvers. What ever there origin, in this chapter we will filter
those outliers.</p>
<a class="header" href="print.html#processing-2" id="processing-2"><h2>Processing</h2></a>
<p>Before, we processed each row individually. Now we need to operate on the entire
sequence. So instead iterating over each row, we are going to transform it
directly.</p>
<p>Because a <code>SimpleCsvReader</code> is an <code>Iterator</code> we can use our tricks on it. The
idiosyncrasies of the <code>SimpleCsvReader</code> make that we first need to unwrap a row.
Next we can map over the row of data and collect into a vector of tuples, the
entry being the time and the second entry being the brightness.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let raw: Vec&lt;(f64, f64)&gt; = reader
    .map(|r| r.unwrap())
    .map(data)
    .collect();
#}</code></pre></pre>
<p>The function <code>data</code> has the following signature</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn data(row: Vec&lt;String&gt;) -&gt; (f64, f64)
#}</code></pre></pre>
<p><code>data</code> is responsible for turning the raw columns of our CSV into <code>f64</code> brightness values,
and selecting the correct ones.</p>
<p>Now that we have our data, we can filter it. Our plan is to keep a vector of
results that we will fill with data-points that we want to keep. We will keep
track of the current data-point, who's type is <code>Option&lt;(f64,f64)&gt;</code> because
before we start iterating over our data we do not have a current data-point.</p>
<p>While iterating over our candidate data-points we compare it to our current
data-point. If the difference in brightness fall between predetermined threshold
we add our current point to the result and update our current data-point.</p>
<p>All in all, something along the lines of</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut result: Vec&lt;(f64, f64)&gt; = vec!();
let mut current: Option&lt;(f64, f64)&gt; = None;
for candidate in raw {
    match current {
        Some(previous) =&gt; {
            if (candidate.1 - previous.1).abs() &lt;= threshold {
                result.push(previous);
                current = Some(candidate);
            }
        }

        None =&gt; {
            current = Some(candidate)
        }
    }
}
#}</code></pre></pre>
<p>The result can be written to a CSV file.</p>
<a class="header" href="print.html#further considerations-4" id="further considerations-4"><h2>Further Considerations</h2></a>
<p>The algorithm above depends on a certain threshold. What value should we use?
Try some different values and try to get a feel for what works. Discuss you
choices with somebody else.</p>
<a class="header" href="print.html#setup" id="setup"><h1>Setup</h1></a>
<p>In this chapter we will setup everything so that you can start working on the
workshop.</p>
<a class="header" href="print.html#prerequisites" id="prerequisites"><h2>Prerequisites</h2></a>
<p>The only real prerequisite is that you have a working
<a href="https://www.rust-lang.org">Rust</a> tool chain. Everything else should be be
provided in the workshop resources.</p>
<p>If you want to graph some of the intermediate results, a graphing tool will be
useful. We would recommend <a href="http://www.gnuplot.info/">gnuplot</a>.</p>
<a class="header" href="print.html#cargo_home" id="cargo_home"><h2>$CARGO_HOME</h2></a>
<p>The project does relies on some crates. In order to go easy on the conference
network we als downloaded the dependencies we envisioned. In order to make use
of this feature these downloaded crates it is necessary to set the <code>$CARGO_HOME</code>
environment variable to <code>&lt;PROJECT_RESOURCES&gt;/cargo_home</code>.</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
